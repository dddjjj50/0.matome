■最初のおまじない
package chap01;
public class Sample01 {		
	public static void main(String[] args) {
	}
}



■標準出力
System.out.print(表示させたい文字列);
System.out.println(表示させたい文字列);  //えるえぬｌｎを入れると（）内を表示させたあとに改行
System.out.print(表示させたい文字列"\n");  //C言語と同じように\nでも改行可能
syso　ctrlスペースですぐ出せる

※printfみたいなのも使える。
System.out.print(("名前: %s, 年齢: %d, 身長: %.2f cm\n", "田中", 25, 175.5);

■改行
System.out.print();  //エラーになる
System.out.println();  //エラーにならない！改行だけできる。

■標準入力
System.in.read();
args)のあとにthrows java.io.IOException{
- System.in.read(); は 1バイト (整数値) の入力を読み込む
- 例えば 'A' を入力すると その ASCII コード (65) が取得される
- System.in.read() の戻り値は int 型なので、変数に格納できる！
int ch = System.in.read(); // キーボード入力を1文字読み込む


■文字列のデータ型
データ型　　　　　変更可否　スレッドセーフ　速度
String　　　　　 変更不可　　安全　　　　　高速
StringBuilder　　変更可　　 安全じゃない　高速
StringBuffer　　 変更可　　 安全　　　　　遅め

■指定子
double　Cでは%lfだけどJavaでは%f

■final変数。代入が1度しかできない。2度目以降でに代入をしようとするとエラーになる。
final データ型 変数名（大文字）;
変数名＝初期値;
C言語でいうconst。

■同じようなの作りたいときは別名保存→クラス名を変えるの忘れない

■関数のとりこみ
int input;
System.out.println("出力の開始");
System.out.print("半角数字を入力してください　：　");
input = System.in.read();
System.out.println("入力した数字は"+input+"です。");

※しかし上記では、1の文字コード「49」が出力されてしまう。
そこでCharacter.digitを使う。

Character.digit(変数名,10)
その変数に入ってる値を10進数として理解してください。
（16進数なら16）
文字コードにできなければ-1になる

input = System.in.read();
input = Character.digit(input,10);	//10進数に変換
//input = Character.digit(System.in.read(),10); でも上記2段と同じ意味。省略ができる


■コンパイルエラーと実行エラー
コンパイルエラー：ソースコードの間違い。文法やスペル。変数名を間違えた、必要な記述が受けた、カッコがおかしい
実行エラー：文法に誤りはないが動作に問題がある。出た値が範囲外とか。

■Math.random()　0.0以上 1.0未満（0 <= Math.random() < 1）のdouble型の乱数値を自動的に発生させる。
・0～9までの乱数の値を代入する
int i;
i=(int)(Math.random()*10);

■フローチャート
プログラム構文とかは書かない。お客さんとの説明で使うから

Math.random()*11-5　-5～5まで出る

■if文、else ifで終わらすとエラーになる可能性ある
if文の条件が複数になるときは && もしくは ||

■A.equals(B) AとBの内容が同一である。
A==B　メモリのアドレスが同じって意味になる
AとBは順不同

■Switch（条件）｛
case　0：　//コロン
　　　処理；
　　　brreak；
…
default：  //必須ではない。条件外はなにも処理されなくなる。が、わかりやすくするため記述したほうが〇
　　　処理；
　　　brreak；
｝
条件の変数に使えるのは
・byte
・char
・short
・int
・String

14以降なら、case 1,2,...:って書いてもOK
break忘れると処理が続いて行ってしまう。

■break　実行している風呂億（forなど）から強制的に処理を終了させる。

■continue　実行している繰り返し文まで強制的に処理を移動させる。
・for文の場合　処理が更新式へ移動する
・while文、do～while文の場合　条件式へ移行する

■配列宣言
Javaでは int num[5]; ではなく、 
・int[] num = new int[5]; 
・int num[] = new int[5]; 
左辺の[]は空白に、右辺の[]に要素数を記入

■データ名.lengthで最初の配列宣言の要素数を変更するだけで、あとのコードを変えなくてよくなる。
ex)　for(int i=0;i<aaa.length;i++) {

■拡張for文
for (要素数のintを宣言：配列）
ex) int num[5];
for(int i:num){
	System.out.println(i)
}
※0からしか参照できない。逆とかできない。

■最大値、最小値。
Math.max(引数1,引数2）
Math.min(引数1,引数2）
引数2こまでなので、3つやりたいときはMath.max（引数1,Math.max(引数2,引数3))て使う。

■data.length=繰り返しと配列のあわせわざで使う

■getAbsolutePath()メソッド　ファイルの絶対パスを得る
isFile()メソッド　ファイルかどうか判断する
isDirectory()メソッド　ディレクトリーかどうか判断する

■ファイル入出力ストリームを使う場合には以下の手順で行う
①ストリームをオープン（定義）する
②データの入出力（読み書き）をする
③ストリームをクローズ（終了）する

■flush();　フラッシュ処理を行う
close();　ストリームのクローズとフラッシュ処理を行う
write();　ファイルへの入力を行う
read();　ファイルからの出力を行う


ストリームとは？
ストリームとは、データの流れ を管理する仕組みです。ファイルの読み書きやネットワーク通信では、データは一気に扱われるのではなく、流れるように順次処理 されます。この 流れるデータの経路 を「ストリーム」と呼びます。
例えば、ファイルを開いてデータを書き込む場合、ストリームを通じてデータが 少しずつ 書き込まれます。これにより、メモリの消費を抑えながら効率的にデータを処理できます。
フラッシュ処理とは？
flush(); は ストリームのバッファ内のデータを即座に書き込む 処理のことです。
バッファってなに？
バッファとは、一時的にデータを溜めておく領域です。ファイルにデータを書き込む際、データを すぐにディスクへ保存せず、メモリ上のバッファに一時的に保持します。これにより、効率的にデータを書き込めます。しかし、バッファ内のデータが すぐに反映されない こともあります。


■length()格納する文字列の文字数を返す
substring()
compareTo()
toUpperCase()
toLowerCase()
trim()
split()

■
Localeクラスが含まれているパッケージ：java.utilパッケージ
数値をフォーマットする；NumberFormatクラス
日時を扱うクラス：Calendarクラス
日付をフォーマットする：DateForamatクラス
数値と日付をフォーマットするクラスが含まれているパッケージ：java.textパッケージ

■ArrayListパッケージ
・java.utilパッケージに含まれている
・コレクションのサイズ（要素数）は自由に変えられる。
・

■例外
コンパイルエラーじゃないけどエラーになるようなコードのとき。
try{
	例外発生するかもな処理
}catch(例外クラス型　引数名){
	例外発生時の処理
}finally{
	例外の発生有無にかかわらず行う処理
}
・catch(例外クラス型　引数名)の部分は複数定義できる。
　　いちいちcatchかいてもいいし
		}catch(例外クラス型　引数名){
		}catch(例外クラス型　引数名){
　　｜使ってもいい。
		}catch(例外クラス型　引数名|例外クラス型　引数名|例外クラス型　引数名){
・try catchじゃなくて、throwsを使ってもいい。
	「修飾子　戻り値の型　メソッド名（引数リスト） throws 例外クラス名｛｝」
	「public void array_check(int i) throws ArrayIndexOutOfBoundsException{}」みたいに。




-------------オブジェクト指向----------------

■クラス　機械でいうｒと部品の設計図
└オブジェクト
　└フィールド
　└コンストラクター：インスタンス化されたときに最初に呼び出される処理。書式は「修飾子 コンストラクター名（データ型 引数名）｛｝」
　└メソッド

■メソッドの書式 →　修飾子 戻り値の型 メソッド名（データ型 引数名, データ型 引数名,,,）｛｝
・修飾子：アクセスできる範囲を指定

■修飾子
強 private(同一クラスからのみアクセス可)
↑  default(privateのアクセス範囲と同一パッケージにあるクラスからアクセス可能)
↓  protected(defaultのアクセス範囲とサブクラスからアクセス可能)
弱 public(すべてのクラスからアクセス可)

■カプセル化…フィールドを外部から直接アクセスできなくする。



■クラス図
抽象クラスならクラス名が斜体になる
＜＜インターフェース＞＞

■継承　あるクラスをもとに新しいクラスを作ること。
元のクラスの機能（フィールドやメソッド）を受け継ぐことができて、
さらに新しい機能（フィールドやメソッド）を追加することができる。これを拡張。

・スーパークラス：元、親のクラス
・サブクラス：親の機能を継承して新たにつくられた子クラス。
サブクラスが継承できるのはひとつのスーパークラスだけ。（単一継承）
「このスーパークラスのこの部分と、別のスーパークラスのこの部分を継承」という多重継承は不可

■パッケージ　別にひとつのアプリでひとつのパッケージじゃない。

----------------------
料理で例える（アラビアータ）
-----------------
■クラスの中にフィールド、コンストラクタ、メソッドがある。
・フィールド　レシピの材料（パスタ、トマト缶、唐辛子…）
・コンストラクタ　下ごしらえ
        （なにを下ごしらえとするかはプログラマーによって違う、フィールドの段階で整えてある場合もあり）
・メソッド　料理の手順（火にかける、混ぜる、味付けのタイミング）
■オブジェクト≒インスタンス（レシピを使って実際に作った料理）
■インスタンス化　　実際に料理をすること。
    arabia_ta todeysDinner = new arabia_ta();
■オーバーロード　同一クラスないにメソッドを複数用意して、少し違うアラビアータを作る（辛さ、具材等）
■アクセス修飾子　レシピの公開範囲

■staticフィールド、staticメソッド
✔ static あり → クラス変数として扱い、クラス名.変数名 でアクセス！
✔ static なし → インスタンス変数なので、オブジェクト.変数名 でアクセス！
✔ static の有無で「変数が共有されるかどうか」が変わる！
フィールドやメソッドにstaticがついていれば、インスタンス生成しなくてもほかのクラスでそのフィールドを使える。
ただし、「そのフィールドがあるクラス名．フィールド名」というふうにもともとのクラスを明記する必要がある。

■継承
クラス名のあとに「extends 継承元のクラス名」をつける。


■フローチャート
プログラム構文とかは書かない。お客さんとの説明で使うから

■UML　Unified Modeling Language
・構造図
　├ クラス図：クラスの構造とクラス間の静的な関係を表現
　├ オブジェクト図：クラスを実体化して生成されたオブジェクト同士の関係を表現（クラス図とほぼ同じ）
　├ パッケージ図：パッケージ同士の依存関係を描くことでグループ化して表現
　├ 複合構造図（コンポジット構造図）：個々のクラスをその構成要素、構成要素の結びつきや役割、外部との境界を表現
　├ コンポーネント図：物理的な構成要素（ファイルなど）からシステムの構造を表現
　└ 配置図（デプロイメント図）：構成するハードウェアとアプリケーションとの関係を表現
・振る舞い図
　├ ユースケース図：システムの役割をユーザーの視点から表現
　├ アクティビティ図：システムの振る舞いを表現
　└ 状態遷移図（状態マシン図、ステートチャート図）：ひとつのオブジェクトの生成から消滅までの状態遷移を表現
・相互作用図
　├ シーケンス図：相互作用するオブジェクト間のメッセージの流れを時系列に表現する
　├ コミュニケーション図（コラボレーション図）：相互作用するオブジェクト間の関係（メッセージやスレッド）の順序を表現
　├ 相互作用概要図：相互作用の実行順序を表現
　└ タイミング図：相互作用と状態遷移に関する時間制約を表現。

・クラス図
-保持するフィールドやメソッドも記述される。
-3つの区画に分かれた四角形
	1番上：クラス名
	真ん中：属性一覧
	1番下：操作一覧
-フィールドの可視性
	下線　static
	-　private　同一クラスのメンバーからのみアクセス可
	~　無指定（default）　private+同一パッケージのメンバーからアクセス可
	#　protected　無指定+サブクラスのメンバーからアクセス可
	+　public　すべてのクラスのメンバーからアクセス可


